<!DOCTYPE html>
<html lang="en" id="top">

<head>

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->

  <meta charset="utf-8">

  <title>Concurrent Requests in Python: httpx vs aiohttp</title>

  <meta name="author" content="Miguel Mendez">
  <meta property="og:website" content="Miguel Mendez personal website">
  <meta name="robots" content="max-image-preview:large">
  <meta name="title" property="og:title" content="Concurrent Requests in Python: httpx vs aiohttp">

  
  <meta name="description" property="og:description" content="In high-concurrency networking situations, handling a large number of requests can lead to different behaviors between httpx and aiohttp. While httpx may fail under heavy load, switching to aiohttp offers a more reliable solution for managing high traffic in asynchronous Python applications. This post explores how httpx struggles with concurrency and how aiohttp outperforms it in such scenarios">
  

  
  <meta name="image" property="og:image" content="https://miguel-mendez-ai.com/assets/images/fullsize/posts/2024-10-20-aiohttp-vs-httpx/thumbnail.jpg">
  

  <meta property="og:url" content="https://miguel-mendez-ai.com/2024/10/20/aiohttp-vs-httpx">

  <!-- Set canonical link to avoid duplication in google search -->
  <link rel="canonical" href="https://miguel-mendez-ai.com/2024/10/20/aiohttp-vs-httpx">

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- CSS
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->

  <!-- preload fonts -->
  <link rel="preload" href="/libs/external/fonts/Graphik-Regular.woff2"" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="/libs/external/fonts/Graphik-Semibold.woff2"" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="/libs/external/fonts/Tiempos-Headline-Semibold.woff2"" as="font" type="font/woff2" crossorigin>

  <link rel="stylesheet" href=/libs/custom/my_css.css>
  <link rel="stylesheet" href=/libs/external/fonts/fonts.css>

  <!-- hack for non critical css https://web.dev/defer-non-critical-css/ -->
  <link rel="preload" href=/libs/custom/syntax.css as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href=/libs/custom/syntax.css></noscript>
  
  <!-- non critical lighthouse css -->
  <link rel="preload" href=/libs/external/lightbox/lightbox.css as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href=/libs/external/lightbox/lightbox.css></noscript>

  <!-- Fontello
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="stylesheet"
    href=/libs/external/fontello-bb2d1770/css/fontello.css>


  <!-- Hihglight.js
  <!-- Preload CSS -->
  <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css"></noscript>
  
  <!-- Load only necessary languages (example: javascript and python) -->
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/yaml.min.js"></script>
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/dockerfile.min.js"></script>


  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href=/libs/icon.png>
  <link rel="shortcut icon" type="image/png" href=/libs/icon.png>

  <!-- Google Analytics -->
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LMHYVFNF1J"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-LMHYVFNF1J');
</script>
    <!-- Twitter cards -->
  <meta name="twitter:site" content="@https://twitter.com/mmeendez8">
  <meta name="twitter:title" content="Concurrent Requests in Python: httpx vs aiohttp">
  
  
  <meta name="twitter:description" content="In high-concurrency networking situations, handling a large number of requests can lead to different behaviors between httpx and aiohttp. While httpx may fail under heavy load, switching to aiohttp offers a more reliable solution for managing high traffic in asynchronous Python applications. This post explores how httpx struggles with concurrency and how aiohttp outperforms it in such scenarios">
  
  

  
  <meta name="twitter:card"  content="summary_large_image">
  <meta name="twitter:image" content="https://miguel-mendez-ai.com/assets/images/fullsize/posts/2024-10-20-aiohttp-vs-httpx/thumbnail.jpg">
  

  <!-- end of Twitter cards -->
  

</head>

<body>

  <!-- schema.org markup to help SEO -->
<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "headline": "Concurrent Requests in Python: httpx vs aiohttp",
    "datePublished": "2024-10-20T00:00:00+00:00",
    "dateModified": "2024-10-20T00:00:00+00:00",
    "author": {
      "@type": "Person",
      "name": "Miguel Mendez",
      "url": "https://miguel-mendez-ai.com"
    },
    "description": "In high-concurrency networking situations, handling a large number of requests can lead to different behaviors between httpx and aiohttp. While httpx may fail under heavy load, switching to aiohttp offers a more reliable solution for managing high traffic in asynchronous Python applications. This post explores how httpx struggles with concurrency and how aiohttp outperforms it in such scenarios"
    "keywords": "Python, aiohttp, httpx, concurrency, networking",
    "articleSection": "Programming, Python, Networking"
  }
  </script>

<header class="the-post-header">
    <div class="container">
      <a href="/">
        <h3>Miguel Méndez</h3>
      </a>
      <div>
        <a  href=/index.html#posts>
         <h3 class="posts-link">Posts</h3>
        </a>
      </div>
    </div>
</header>

<div class="the-post-title-placeholder">
  <div class="offset">
    <div class="the-post-title-text">
      <span class="the-post-date">October 20, 2024 </span>
      <h1 class="the-post-title">Concurrent Requests in Python: httpx vs aiohttp</h1>
      <p>How switching from httpx to aiohttp resolved my networking errors</p>
    </div>
  </div>

  <div class="the-post-title-image">
    <img src="/generated/assets/images/fullsize/posts/2024-10-20-aiohttp-vs-httpx/thumbnail-800-83878bcb5.jpg" alt="Concurrent Requests in Python: httpx vs aiohttp" srcset="/generated/assets/images/fullsize/posts/2024-10-20-aiohttp-vs-httpx/thumbnail-400-00d0f72ea.webp 400w, /generated/assets/images/fullsize/posts/2024-10-20-aiohttp-vs-httpx/thumbnail-800-00d0f72ea.webp 800w, /generated/assets/images/fullsize/posts/2024-10-20-aiohttp-vs-httpx/thumbnail-1500-00d0f72ea.webp 1500w, /generated/assets/images/fullsize/posts/2024-10-20-aiohttp-vs-httpx/thumbnail-2000-00d0f72ea.webp 2000w" sizes="(max-width: 767px) 100vw, 50vw" width="2000" height="1425">

  </div>
</div>

<div class="share-button">
  <a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class="twitter-share-button" data-show-count="false" ,
    data-size="large" , data-text="Concurrent Requests in Python: httpx vs aiohttp" , data-via="mmeendez8" , data-url="https://miguel-mendez-ai.com/2024/10/20/aiohttp-vs-httpx">
  </a>
</div>

<div class="container the-post-content">

  <p>Over the past couple of weeks, I encountered a tricky bug while working on a computer vision application. After spending time troubleshooting, I decide to write this post since it might help other people to avoid the same issue.</p>

<h2 id="the-setup">The Setup</h2>

<p>I have a computer vision REST API that receives images and returns predictions. The setup includes several replicas running behind a load balancer, and each server batches requests to maximize GPU usage and minimize latency—a fairly common setup for computer vision applications. Here’s a simple diagram showing the flow of requests from the client to the server:</p>

<div class="post-center-image">
    <a href="/assets/images/fullsize/posts/2024-10-20-aiohttp-vs-httpx/architecture.jpg">
  <img loading="lazy" src="/generated/assets/images/fullsize/posts/2024-10-20-aiohttp-vs-httpx/architecture-800-d9bf89083.jpg" alt="Application Diagram" srcset="/generated/assets/images/fullsize/posts/2024-10-20-aiohttp-vs-httpx/architecture-400-c9c164616.webp 400w, /generated/assets/images/fullsize/posts/2024-10-20-aiohttp-vs-httpx/architecture-800-c9c164616.webp 800w, /generated/assets/images/fullsize/posts/2024-10-20-aiohttp-vs-httpx/architecture-1500-c9c164616.webp 1500w, /generated/assets/images/fullsize/posts/2024-10-20-aiohttp-vs-httpx/architecture-1506-c9c164616.webp 1506w" sizes="(max-width: 767px) 100vw, 80vw" width="1506" height="663" />
</a>

</div>

<p>I was using the <code>httpx</code> library from my Python client to send requests asynchronously to this service. Initially, things worked fine, but as the traffic increased, random errors started appearing. These errors were intermittent, making it even harder to trace the root cause and putting my patience to the limit.</p>

<p>Note that these are the library versions I am using across this post:</p>

<pre><code class="language-bash">python                            3.11.3
aiohttp                           3.10.10
httpx                             0.27.2
</code></pre>

<h2 id="the-problem">The Problem</h2>

<p>I initially chose <code>httpx</code> for my client due to its modern async/await support and its recommendation in FastAPI’s documentation. It seemed like a solid choice for handling concurrent requests. However, as I ramped up the number of requests, I began encountering random crashes that were difficult to debug. The errors weren’t immediately obvious, and it took time to isolate the issue as being related to <code>httpx</code>. Here’s a minimal example of the client-server setup I was working with.</p>

<h3 id="server-code-fastapi">Server Code (FastAPI)</h3>

<pre><code class="language-python">from fastapi import FastAPI
from pydantic import BaseModel, Field
import asyncio
import uvicorn

app = FastAPI()

class ImagePayload(BaseModel):
    image: str = Field(..., description="Base64 encoded image")

@app.post("/process_image")
async def process_image(payload: ImagePayload):
    await asyncio.sleep(3)

    return {
        "message": "Image processed successfully after a delay"
    }

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
</code></pre>

<h3 id="httpx-client-code">Httpx Client Code</h3>

<p>This is the client code that sends a lot of requests concurrently to the server. Note I have added a few variables here:</p>

<ul>
  <li><code>CONCURRENT_REQUESTS</code>: The number of concurrent requests that will be sent to the server</li>
  <li><code>TOTAL_REQUESTS</code>: The total number of requests that will be sent to the server</li>
  <li><code>TIMEOUT</code>: The timeout in seconds for each individual request</li>
</ul>

<pre><code class="language-python">import asyncio
import httpx
import base64
import numpy as np

SERVER_URL = "http://localhost:8000/process_image"

CONCURRENT_REQUESTS = 300
TOTAL_REQUESTS = 1000
TIMEOUT = 30

async def send_request(client, image_data):
    response = await client.post(SERVER_URL, json={"image": image_data})
    return response.json()

async def main():
    image = np.random.randint(0, 255, (100, 100, 3), dtype=np.uint8)
    image_data = base64.b64encode(image).decode()
    
    async with httpx.AsyncClient(limits=httpx.Limits(max_connections=CONCURRENT_REQUESTS), verify=False, timeout=TIMEOUT) as client:
        tasks = [send_request(client, image_data) for _ in range(TOTAL_REQUESTS)]
        results = await asyncio.gather(*tasks)

    for i, result in enumerate(results, 1):
        print(f"Response {i}:", result)

if __name__ == "__main__":
    asyncio.run(main())
</code></pre>

<p>When I run this code I see that a lot of requests succeed but suddenly the whole program crashes with the following error:</p>

<pre><code class="language-bash">(the exception is too long to be shown here)
  File "/home/mmendez/pypoetry/virtualenvs/example//lib/python3.11/site-packages/httpx/_client.py", line 1776, in _send_single_request
    response = await transport.handle_async_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/mmendez/pypoetry/virtualenvs/example//lib/python3.11/site-packages/httpx/_transports/default.py", line 376, in handle_async_request
    with map_httpcore_exceptions():
  File "/home/mmendez/.pyenv/versions/3.11.3/lib/python3.11/contextlib.py", line 155, in __exit__
    self.gen.throw(typ, value, traceback)
  File "/home/mmendez/pypoetry/virtualenvs/example//lib/python3.11/site-packages/httpx/_transports/default.py", line 89, in map_httpcore_exceptions
    raise mapped_exc(message) from exc
httpx.ReadError
</code></pre>

<p>This is quite frustrating because <code>httpx.ReadError</code> is a generic error indicating that something went wrong while reading the response from the server, but it doesn’t give much detail. What made this especially challenging is that on my application the error wasn’t consistent. It only occurred under heavy traffic, and even then, it didn’t happen every time.</p>

<h2 id="the-fix-switch-to-aiohttp">The Fix: Switch to aiohttp</h2>

<p>After searching through the <code>httpx</code> GitHub repository, I found upon this <a href="https://github.com/encode/httpx/issues/3215" target="_blank" rel="noopener noreferrer">issue</a>, which provided insight into the performance limitations of <code>httpx</code> when compared to <code>aiohttp</code>. This is another popular library for handling asynchronous HTTP requests in Python. The solution became clear: switch to <code>aiohttp</code> and see if the problem persists.</p>

<p>Here’s how the client code looks after switching to aiohttp:</p>

<pre><code class="language-python">import asyncio
import aiohttp
import base64
import numpy as np

SERVER_URL = "http://localhost:8000/process_image"
CONCURRENT_REQUESTS = 300
TOTAL_REQUESTS = 1000
TIMEOUT = 30

async def send_request(session, image_data):
    async with session.post(SERVER_URL, json={"image": image_data}) as response:
        return await response.json()

async def main():
    image = np.random.randint(0, 255, (100, 100, 3), dtype=np.uint8)
    image_data = base64.b64encode(image.tobytes()).decode()
    
    timeout = aiohttp.ClientTimeout(total=TIMEOUT)
    connector = aiohttp.TCPConnector(limit=CONCURRENT_REQUESTS)
    
    async with aiohttp.ClientSession(timeout=timeout, connector=connector) as session:
        tasks = [send_request(session, image_data) for _ in range(TOTAL_REQUESTS)]
        
        results = await asyncio.gather(*tasks)

    for i, result in enumerate(results, 1):
        print(f"Response {i}:", result)

if __name__ == "__main__":
    asyncio.run(main())
</code></pre>

<p>This simple change resolved all the random errors and even improved the overall performance.</p>

<h2 id="conclusion">Conclusion</h2>

<p>If you’re building an application that needs to handle a large number of concurrent requests, especially in a production environment, I recommend switching to <code>aiohttp</code>. While <code>httpx</code> is a great library, it may not be the best choice for high-concurrency use cases just yet. Hopefully, these issues will be resolved soon, but until then, <code>aiohttp</code> has proven to be a more reliable choice.</p>

  
</div>

<div class="comments">
  <script src="https://utteranc.es/client.js"
        repo="mmeendez8/mmeendez8.github.io"
        issue-term="url"
        theme="github-light"
        crossorigin="anonymous"
        async>
  </script>
</div>

    <div class="footer">
      <div class="footer-sign">
      <p> <a  href=/index.html#top>Miguel Mendez </a></p>
      </div>

      <div class="footer-thanks">
        <p>based on <a href="http://web.media.mit.edu/~msaveski" target="_blank" rel="noopener">Martin Saveski</a> and <a href='https://marinaaisa.com/' target="_blank" rel="noopener">Marina Aisa</a> templates</p>
      </div>

      <div class="footer-icons">
        <a href='https://github.com/mmeendez8' target="_blank" rel="noopener">
          <i class="icon-github-circled" aria-hidden="true"></i>
        </a>

        <a href='https://www.linkedin.com/in/miguel-mendez/' target="_blank" rel="noopener">
          <i class="icon-linkedin-squared" aria-hidden="true"></i>
        </a>

        <a href='https://twitter.com/mmeendez8' target="_blank" rel="noopener">
          <i class="icon-twitter-squared" aria-hidden="true"></i>
        </a>

        <a href='https://medium.com/@miguelmendez_' target="_blank" rel="noopener">
          <i class="icon-medium" aria-hidden="true"></i>
        </a>

        <a href='https://stackoverflow.com/users/8380638/m33n' target="_blank" rel="noopener">
          <i class="icon-stackoverflow" aria-hidden="true"></i>
        </a>

        <a href='/feed.xml' target="_blank" rel="noopener">
          <i class="icon-rss-squared" aria-hidden="true"></i>
        </a>
        
      </div>

    </div>

  <!-- End Document
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <script type="text/javascript" src=/libs/external/lightbox/lightbox.js defer></script>
  
  <!-- Mathjax -->
  
    <script type="text/javascript" defer src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [["$", "$"], ["\\(", "\\)"]],
          processEscapes: true
      }
  });
</script>
  

  <!-- Highlight.js -->
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
        hljs.highlightAll();
    });
</script>

</body>

</html>
